# -*- coding: utf-8 -*-
"""loan_pred.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u9Mo_ptHvl_p7E9JG92Iy7w-2F2Tmxow
"""

import pandas as pd
from sklearn.preprocessing import LabelEncoder,OneHotEncoder,MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn import metrics
import numpy as np
import seaborn as sns

loan_data=pd.read_csv('/content/drive/My Drive/loan_pred/train_ctrUa4K.csv')
loan_data.head(3)

loan_data.shape

loan_data.isnull().sum()

modified_data=loan_data[['Dependents','Gender','Married','Education','Self_Employed','ApplicantIncome','CoapplicantIncome','LoanAmount','Loan_Amount_Term','Property_Area','Credit_History']]
modified_data.head()

#print(modified_data['Gender'].value_counts())
#print(modified_data['Married'].value_counts())
#print(modified_data['Dependents'].value_counts())
#print(modified_data['Education'].value_counts())
#print(modified_data['Self_Employed'].value_counts())
print(modified_data['Property_Area'].value_counts())
print(modified_data['Credit_History'].value_counts())

for i in range(len(modified_data['Gender'])):
  if(modified_data['Gender'][i] != 'Male' and modified_data['Gender'][i] !="Female"):
    modified_data['Gender'][i]='Male'

for i in range(len(modified_data['Married'])):
  if(modified_data['Married'][i] != 'No' and modified_data['Married'][i] !="Yes"):
    modified_data['Married'][i]='Yes'

for i in range(len(modified_data['Dependents'])):
  if(modified_data['Dependents'][i] != '0' and modified_data['Dependents'][i] !="1" and modified_data['Dependents'][i] !="2" and modified_data['Dependents'][i] !="3+"):
    modified_data['Dependents'][i]='0'



for i in range(len(modified_data['Dependents'])):
  if( modified_data['Dependents'][i] =="3+"):
    modified_data['Dependents'][i]='3'







for i in range(len(modified_data['Education'])):
  if(modified_data['Education'][i] != 'Graduate' and modified_data['Education'][i] !="Not Graduate" ):
    modified_data['Education'][i]='Graduate'

for i in range(len(modified_data['Self_Employed'])):
  if(modified_data['Self_Employed'][i] != 'No' and modified_data['Self_Employed'][i] !="Yes" ):
    modified_data['Self_Employed'][i]='Yes'





print(6+9)

enc=LabelEncoder()
modified_data['Gender']=enc.fit_transform(modified_data[['Gender']])
modified_data['Married']=enc.fit_transform(modified_data[['Married']])
modified_data['Education']=enc.fit_transform(modified_data[['Education']])
modified_data['Self_Employed']=enc.fit_transform(modified_data[['Self_Employed']])
modified_data['Property_Area']=enc.fit_transform(modified_data[['Property_Area']])
modified_data.head()

modified_data.isnull().sum()



one_hot=OneHotEncoder(handle_unknown='ignore')

from sklearn.impute import SimpleImputer
imp=SimpleImputer()
modified_data['Credit_History']=imp.fit_transform(modified_data['Credit_History'].values.reshape(-1,1))
modified_data_new

#modified_data['Gender'].values.reshape(-1,1)


#modified_data_new=pd.DataFrame(one_hot.fit_transform(modified_data.values.reshape(-1,1)).toarray())
#modified_data

scaler=MinMaxScaler()
final_data=scaler.fit_transform(modified_data_new)
final_data

X=final_data
Y=loan_data[['Loan_Status']]
Y=enc.fit_transform(Y)
#ravel().Y = Y(Y, warn=True)
X_train,X_test,Y_train,Y_test=train_test_split(X,Y,test_size=0.2)

from sklearn.linear_model import LogisticRegression
lr_classify=LogisticRegression()
lr_classify.fit(X_train,Y_train)

Y_pred=lr_classify.predict(X_test)
import matplotlib.pyplot as plt

confusion_matrix = metrics.confusion_matrix(Y_test, Y_pred)
class_names=[0,1] # name of classes
fig, ax = plt.subplots()
tick_marks = np.arange(len(class_names))
plt.xticks(tick_marks, class_names)
plt.yticks(tick_marks, class_names)

# The heatmap requires that we pass in a dataframe as the argument
sns.heatmap(pd.DataFrame(confusion_matrix), annot=True, cmap="YlGnBu", fmt="g")

# Configure the heatmap parameters
ax.xaxis.set_label_position("top")
plt.tight_layout()
plt.title('Confusion matrix', y=1.1)
plt.ylabel('Actual label')
plt.xlabel('Predicted label')

print("Accuracy:",metrics.accuracy_score(Y_test, Y_pred))
print("Precision:",metrics.precision_score(Y_test, Y_pred))
print("Recall:",metrics.recall_score(Y_test, Y_pred))

print("f1 score:",metrics.f1_score(Y_test,Y_pred))

import pickle

pickle.dump(lr_classify,open('model.pkl','wb'))